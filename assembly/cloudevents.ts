// Code generated by protoc-gen-as. DO NOT EDIT.
// Versions:
//   protoc-gen-as v0.9.1
//   protoc        v3.19.6

import { Writer, Reader } from "as-proto/assembly";
import { google } from "./google/protobuf/any";
import { google as google_2 } from "./google/protobuf/timestamp";

export namespace io {
  export namespace cloudevents {
    export namespace v1 {
      export class CloudEvent {
        static encode(message: CloudEvent, writer: Writer): void {
          writer.uint32(10);
          writer.string(message.id);

          writer.uint32(18);
          writer.string(message.source);

          writer.uint32(26);
          writer.string(message.specVersion);

          writer.uint32(34);
          writer.string(message.type);

          const attributes = message.attributes;
          if (attributes !== null) {
            const attributesKeys = attributes.keys();
            for (let i: i32 = 0; i < attributesKeys.length; ++i) {
              const attributesKey = attributesKeys[i];
              writer.uint32(42);
              writer.fork();
              writer.uint32(10);
              writer.string(attributesKey);
              writer.uint32(18);
              writer.fork();
              io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.encode(
                attributes.get(attributesKey),
                writer
              );
              writer.ldelim();
              writer.ldelim();
            }
          }

          writer.uint32(50);
          writer.bytes(message.binaryData);

          writer.uint32(58);
          writer.string(message.textData);

          const protoData = message.protoData;
          if (protoData !== null) {
            writer.uint32(66);
            writer.fork();
            google.protobuf.Any.encode(protoData, writer);
            writer.ldelim();
          }
        }

        static decode(reader: Reader, length: i32): CloudEvent {
          const end: usize = length < 0 ? reader.end : reader.ptr + length;
          const message = new CloudEvent();

          while (reader.ptr < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.id = reader.string();
                break;

              case 2:
                message.source = reader.string();
                break;

              case 3:
                message.specVersion = reader.string();
                break;

              case 4:
                message.type = reader.string();
                break;

              case 5:
                let attributesKey: string = "";
                let attributesValue: io.cloudevents.v1.CloudEvent.CloudEventAttributeValue | null =
                  null;
                let attributesHasKey: bool = false;
                let attributesHasValue: bool = false;
                for (
                  const end: usize = reader.ptr + reader.uint32();
                  reader.ptr < end;

                ) {
                  const tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1:
                      attributesKey = reader.string();
                      attributesHasKey = true;
                      break;

                    case 2:
                      attributesValue =
                        io.cloudevents.v1.CloudEvent.CloudEventAttributeValue.decode(
                          reader,
                          reader.uint32()
                        );
                      attributesHasValue = true;
                      break;

                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                  if (message.attributes === null) {
                    message.attributes = new Map<
                      string,
                      io.cloudevents.v1.CloudEvent.CloudEventAttributeValue
                    >();
                  }
                  const attributes = message.attributes;
                  if (
                    attributes !== null &&
                    attributesHasKey &&
                    attributesHasValue &&
                    attributesValue !== null
                  ) {
                    attributes.set(attributesKey, attributesValue);
                  }
                }
                break;

              case 6:
                message.binaryData = reader.bytes();
                break;

              case 7:
                message.textData = reader.string();
                break;

              case 8:
                message.protoData = google.protobuf.Any.decode(
                  reader,
                  reader.uint32()
                );
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
          }

          return message;
        }

        id: string;
        source: string;
        specVersion: string;
        type: string;
        attributes: Map<
          string,
          io.cloudevents.v1.CloudEvent.CloudEventAttributeValue
        >;
        binaryData: Uint8Array;
        textData: string;
        protoData: google.protobuf.Any | null;

        constructor(
          id: string = "",
          source: string = "",
          specVersion: string = "",
          type: string = "",
          attributes: Map<
            string,
            io.cloudevents.v1.CloudEvent.CloudEventAttributeValue
          > = new Map(),
          binaryData: Uint8Array = new Uint8Array(0),
          textData: string = "",
          protoData: google.protobuf.Any | null = null
        ) {
          this.id = id;
          this.source = source;
          this.specVersion = specVersion;
          this.type = type;
          this.attributes = attributes;
          this.binaryData = binaryData;
          this.textData = textData;
          this.protoData = protoData;
        }
      }

      export namespace CloudEvent {
        export class CloudEventAttributeValue {
          static encode(
            message: CloudEventAttributeValue,
            writer: Writer
          ): void {
            writer.uint32(8);
            writer.bool(message.ceBoolean);

            writer.uint32(16);
            writer.int32(message.ceInteger);

            writer.uint32(26);
            writer.string(message.ceString);

            writer.uint32(34);
            writer.bytes(message.ceBytes);

            writer.uint32(42);
            writer.string(message.ceUri);

            writer.uint32(50);
            writer.string(message.ceUriRef);

            const ceTimestamp = message.ceTimestamp;
            if (ceTimestamp !== null) {
              writer.uint32(58);
              writer.fork();
              google_2.protobuf.Timestamp.encode(ceTimestamp, writer);
              writer.ldelim();
            }
          }

          static decode(reader: Reader, length: i32): CloudEventAttributeValue {
            const end: usize = length < 0 ? reader.end : reader.ptr + length;
            const message = new CloudEventAttributeValue();

            while (reader.ptr < end) {
              const tag = reader.uint32();
              switch (tag >>> 3) {
                case 1:
                  message.ceBoolean = reader.bool();
                  break;

                case 2:
                  message.ceInteger = reader.int32();
                  break;

                case 3:
                  message.ceString = reader.string();
                  break;

                case 4:
                  message.ceBytes = reader.bytes();
                  break;

                case 5:
                  message.ceUri = reader.string();
                  break;

                case 6:
                  message.ceUriRef = reader.string();
                  break;

                case 7:
                  message.ceTimestamp = google_2.protobuf.Timestamp.decode(
                    reader,
                    reader.uint32()
                  );
                  break;

                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }

            return message;
          }

          ceBoolean: bool;
          ceInteger: i32;
          ceString: string;
          ceBytes: Uint8Array;
          ceUri: string;
          ceUriRef: string;
          ceTimestamp: google_2.protobuf.Timestamp | null;

          constructor(
            ceBoolean: bool = false,
            ceInteger: i32 = 0,
            ceString: string = "",
            ceBytes: Uint8Array = new Uint8Array(0),
            ceUri: string = "",
            ceUriRef: string = "",
            ceTimestamp: google_2.protobuf.Timestamp | null = null
          ) {
            this.ceBoolean = ceBoolean;
            this.ceInteger = ceInteger;
            this.ceString = ceString;
            this.ceBytes = ceBytes;
            this.ceUri = ceUri;
            this.ceUriRef = ceUriRef;
            this.ceTimestamp = ceTimestamp;
          }
        }
      }

      export class CloudEventBatch {
        static encode(message: CloudEventBatch, writer: Writer): void {
          const events = message.events;
          for (let i: i32 = 0; i < events.length; ++i) {
            writer.uint32(10);
            writer.fork();
            io.cloudevents.v1.CloudEvent.encode(events[i], writer);
            writer.ldelim();
          }
        }

        static decode(reader: Reader, length: i32): CloudEventBatch {
          const end: usize = length < 0 ? reader.end : reader.ptr + length;
          const message = new CloudEventBatch();

          while (reader.ptr < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.events.push(
                  io.cloudevents.v1.CloudEvent.decode(reader, reader.uint32())
                );
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
          }

          return message;
        }

        events: Array<io.cloudevents.v1.CloudEvent>;

        constructor(events: Array<io.cloudevents.v1.CloudEvent> = []) {
          this.events = events;
        }
      }
    }
  }
}
